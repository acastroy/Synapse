<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- (C)edwin@datux.nl - released under GPL -->
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<title>internetpapier.nl - BETA</title>

	<script type="text/javascript" src="synapse.js"></script>
	<script type="text/javascript" src="jquery.url.js"></script>

	<script type="text/javascript">

		function Cpoint(x,y)
		{
			this.x=x;
			this.y=y;
	
			this.copy=function(point)
			{
				this.x=point.x;
				this.y=point.y;
			}
			
		}
	
		var mouseInterval=50; //max update inteval in mS (can be higer if mouseMax is exceeded)
		var mouseMax=25; //max mouse pixel offset before sending (regardless of update interval)
	
		var mousePoint=new Cpoint(); //current mouse position
	
		//mouse info sending to server:
		var mouseSendPoint=new Cpoint(); //last mousepoint sent to server
		var mouseSendTime=0; //last time the mousePosition was anaylsed by updateGameField
	
		var mouseDraw=0;		
	
		var contextDraw;
		var contextTemp;
	
		var currentObjectId=0;
		var paperModId=0;
	
		var drawMode="l";
			
		//incremental draw stuff
		var clientId=0;
		var clients=new Array(); 
		var ourId=0;

		var canvasWidth=0;
		var canvasHeight=0;

		var autoCommit=false;

		
		//filter dangerous stuff from user input.
		//NOTE: do this when you receive the data back from the server, not when sending to it!
		function filterInput(s)
		{
			return(s.replace(/</g,"&lt;").replace(/>/g,"&gt;"));

		}

		//calculate browser coordinates to server coordinates
		function toServer(x,y)
		{
			return ({
				"x":Math.round((x * 10000) / canvasWidth),
				"y":Math.round((y * 10000) / canvasHeight)
			});
		}
	
		//calculate server coordinates to browser coordinates 
		function toBrowser(x,y)
		{
			return ({
				"x":((x*canvasWidth)/10000),
				"y":((y*canvasHeight)/10000)
			});
		}				

		//calculate server line width to browser linewidth
		function widthToBrowser(width)
		{
			//for now we use the average of canvas width and height
			return (
					(((width*canvasWidth)/1000)+((width*canvasWidth)/1000))/2
			);
		}

		


		
		//information about the object a client is currently drawing
		function Cclient()
		{
			this.mode="m";
			this.coords=new Array();
			this.color="#000000";
			this.width=widthToBrowser(1);
			this.serverWidth=1;
			this.text="";
			this.cursorX=0;
			this.cursorY=0;
			this.clientName="";
			this.id=0;
			
			//draw the object in the specified context	
			this.draw=function(context)
			{
				if (this.mode=="m")
					return;

				if (this.mode=="l" && this.coords.length>=4)
				{
					context.beginPath();
					context.strokeStyle=this.color;
					context.lineWidth=this.width;
					context.lineCap="round";
					context.lineJoin="round";
	 				context.moveTo(this.coords[0], this.coords[1]);
	 				var i=2;
	 				while (i<this.coords.length)
	 				{
	 					context.lineTo(this.coords[i], this.coords[i+1]);
	 					i=i+2;
	 				}
					context.stroke();
				}
			}

			//draw the cursor of the client
			this.drawCursor=function(context)
			{
				var cW=canvasWidth/100;

				//cross hair
				context.beginPath();
				context.strokeStyle=this.color;
				context.lineWidth=1;
				context.moveTo(this.cursorX-cW, this.cursorY);
				context.lineTo(this.cursorX+cW, this.cursorY);
				context.moveTo(this.cursorX, this.cursorY-cW);
				context.lineTo(this.cursorX, this.cursorY+cW);
				context.stroke();

				//pixel
				context.beginPath();
				context.lineCap="round";
				context.strokeStyle=this.color;
				context.lineWidth=this.width;
				context.moveTo(this.cursorX, this.cursorY);
				context.lineTo(this.cursorX+0.001, this.cursorY+0.001);
				context.stroke();
			}

			//update the html information about this client in the clientlist
			this.updateHtml=function()
			{
				//dont do html stuff when in autoCommit mode, for performance reasons
				if (autoCommit)
					return;
				
		 		//no dom object for this client yet?
				if ($("#client_"+this.id).length==0)
				{
					//add dom object to list
					var html="<div class='client' id='client_"+this.id+"'>";
					html+="</div>";
					$('#clientList').append(html);
				}
				object=$("#client_"+this.id);

				//name 
				if (!this.clientName)
					object.html("Client #" +this.id);
				else
					object.html(this.clientName);

				//color
				object.css('color',this.color);
				if (this.color=="#ffffff")
					object.css('background-color','#cccccc');
				else
					object.css('background-color','#ffffff');

				//"width"
				var size=0;
				if (this.serverWidth<10)
					size=(90+(this.serverWidth*10));
				else
				{
					size=(160+this.serverWidth);
				}
				object.css('font-size',""+size+"%");
	
				//drawing
				if (this.mode!="m")
					object.css('font-style','italic');
				else
					object.css('font-style','');
			} 	

			//we're going to be removed, clean up any shit
			this.remove=function()
			{
				//remove dom object
				if ($("#client_"+this.id).length!=0)
		 			$("#client_"+this.id).remove();

			}
			
			//clears the current draw-info, not the settings!
			this.clear=function()
			{
				this.mode="m";
				this.coords=[];
			}

			//commit the current drawing to permanent canvas, and clear it.
			this.commit=function()
			{
				this.draw(contextDraw);
				this.clear(); 			
			}
			
			/*** Drawing protocol
			//global commands:
			'S'							Start comlete redraw: clear everything, after this all drawing commands will follow, but without explicit commits (to save space)
			'E'							End of complete redraw. 
			'I',<id>					Select a different client ID. (every client has its own color, line width etc settings) Usually the server automaticly sets this parameter.
			'N',<id>					To indicate next drawing <id>
			'P',<id>					To indicate previous drawing <id>
			
			//client settings:
			'c',<htmlcolor>				Set current drawing color
			'w',<w>						Set current line width
			'n',"name"					Set client name

			//client commands:
			's'							write current drawing action permanently
			'x'							Cancel the current drawing action.  
			'm',<x>,<y>					Update cursor location
			'l',<x>,<y>,...				Enable line drawing. (next x,y coords will draw from now on)
			'r',<x1>,<y1>,<x2>,<y2>		Draw rectangle
			'a',<x1>,<y1>,<x2>,<y2>		Draw circle
			't',<x>,<y>,"text"			Draw text
			'.',"text"					Chat text
			
			'
			 */
			//eats and processes the client commands from the array and returns as soon as it encounters a global command
			this.add=function(commands)
			{
				var ok=false;
				while (commands.length>0)
				{	
					//a new command should automaticly commit the previous one:
					//(this way the server doesnt have to store all the save-commands)

					//NOTE: try to sort this on the stuff that is used most often in Redraw mode.
					
					//all numbers are coords, if we are in some kind of drawing mode.
					if (commands[0] == parseInt(commands[0]))
					{
						c=toBrowser(commands.shift(), commands.shift());
						this.cursorX=c.x;
						this.cursorY=c.y;
						if (this.mode=='l')
							this.coords.push(c.x, c.y);
					}
					//enable line mode
					else if (commands[0]=='l')
					{
						this.commit();
						commands.shift();
						this.mode='l';						
						this.updateHtml();						
					}
	 				//save current action permanently 
	 				else if (commands[0]=="s")
	 				{
	 	 				commands.shift();
	 	 				this.commit();
						this.updateHtml();						
	 				}
					//mouse movement
					else if (commands[0]=="m")
	 				{
						this.commit();
		 				commands.shift();
						c=toBrowser(commands.shift(), commands.shift());
		 				this.cursorX=c.x;
		 				this.cursorY=c.y;
		 				this.mode='m';
	 				}
					//color
					else if (commands[0]=='c')
					{
						this.commit();
						commands.shift();
						this.color=commands.shift();
						this.updateHtml();						
					}
					//name
					else if (commands[0]=='n')
					{
						this.commit();
						commands.shift();
						//dont forget to filter!
						this.clientName=filterInput(commands.shift()).substr(0,20);
						this.updateHtml();						
					}
					//chat text
					else if (commands[0]=='.')
					{
						this.commit();
						commands.shift();

						//add text to chatList
						var html="";
						html+="<div class='chatLine'>&lt;";
						html+=this.clientName;
						html+="&gt; ";
						html+=filterInput(commands.shift());
						html+="</div>";
						$('#chatList').append(html);

						//scroll to end
						var objDiv = document.getElementById("chatList");
						objDiv.scrollTop = objDiv.scrollHeight;
						
					}					
					//width
					else if (commands[0]=='w')
					{
						this.commit();
						commands.shift();
						this.serverWidth=parseInt(commands.shift());
						this.width=widthToBrowser(this.serverWidth);
						this.updateHtml();						
					}
	 				//cancel current drawing action
	 				else if (commands[0]=="x")
	 				{
	 	 				commands.shift();
	 					this.clear();
						this.updateHtml();						
	 				}
					else
					{
						//we dont know, let caller handle the rest
						return(ok);
					}
					ok=true;
				}
				return(ok);
			}
		}

		

		//redraw all the clients in the temporary context
		function drawClients()
		{
			contextTemp.clearRect(0, 0, canvasWidth, canvasHeight);
			contextTemp.globalAlpha=0.8;
	
			//draw current objects
			for (var clientI in clients)
			{
				clients[clientI].draw(contextTemp);
				clients[clientI].drawCursor(contextTemp);
			}
		}



		//send drawing commands to server and draw them locally as well
		//note: you need to specifiy server coordinates instead of browser coordinates here.		
		function sendDraw(commands)
		{
			//only if we're joined to something
			if (!currentObjectId)
				return;
			
			//send it to server
			send(paperModId,"paper_ClientDraw", commands);

			//we dont get our own stuff back from the server, so we can add here.
			//this way the users doesnt see his own stuff lagged.
			//however there is a race condition when 2 users draw over eachother and release the mouse at the same time. 
			//both users will get a different result. however this is fixed on a refresh and acceptable for now.
 			
 			if (clients[ourId]==undefined)
 			{
 	 			//NOTE:code duplication
	 			clients[ourId]=new Cclient();
	 			clients[ourId].id=ourId;
 			}

			clients[ourId].add(commands);


			//refresh temporary canvas
			drawClients();
		}

		function mouseMove()
		{
			//mouse throttling function, to prevent too many updates per second
			//no change?
			if (mousePoint.x==mouseSendPoint.x && mousePoint.y==mouseSendPoint.y)
				return;

			currentTime=new Date().getTime();

			//send updates at a max fps, or more when the mouse moves fast
			if (	(currentTime-mouseSendTime>=mouseInterval) || 
					Math.abs(mousePoint.x-mouseSendPoint.x)> mouseMax ||
					Math.abs(mousePoint.y-mouseSendPoint.y)> mouseMax
			)
			{ 

				a=toServer(mousePoint.x,mousePoint.y);
				if (mouseDraw)
					sendDraw([ a.x, a.y ]);
				else
					sendDraw([ "m", a.x, a.y ]);
					

				mouseSendPoint.x=mousePoint.x;
				mouseSendPoint.y=mousePoint.y;
				mouseSendTime=currentTime;
			}
		}	
	
		
 		synapse_register("module_SessionStart",function(msg_src, msg_dst, msg_event, msg)
 		{
			ourId=msg_dst;

			/// figure out client name
			var clientName=$.readCookie('clientName', { path:"/" } );
			if (!clientName)
			{
				//make up a "random" guest name
				clientName="User "+msg_dst;
			}
			
			//set the name input field
			$("#clientName").val(clientName);
			
			/// start local engine
			window.setInterval(mouseMove, mouseInterval);

			
			/// JAVA SCRIPT EVENT HANDLERS

			$("#clientName").keyup(function(m)
			{
				$.setCookie('clientName', $("#clientName").val(), { duration:365, path:"/" });
				sendDraw( [ "n" , $("#clientName").val() ] );
			});

			$("#chatInput").keydown(function(m)
			{
				if (m.keyCode==13)
				{
					sendDraw( [ "." , $("#chatInput").val() ] );
					sendDraw( [ "s" ] );
					$("#chatInput").val("");						
				}					
	 		});

			$("#chatInput").val("");
			$("#chatInput").focus();
			
			$("#canvasMouse").mousemove(function(m)
			{
				mousePoint.x=m.pageX-$("#canvasMouse").offset().left;
				mousePoint.y=m.pageY-$("#canvasMouse").offset().top;
				mouseMove();

			});

			$("#canvasMouse").mousedown(function(m)
			{
				m.preventDefault();
				mouseDraw=1;
				if (drawMode=="l")
				{
					a=toServer(mousePoint.x,mousePoint.y);
					sendDraw( [ "l", a.x, a.y ]);
				}
			});
					
			$("#canvasMouse").mouseup(function(m)
			{
				mouseDraw=0;
				sendDraw( [ "s" ]);
			});
					

			$("#canvasMouse").mouseleave(function(m)
			{
				if (mouseDraw)
				{
					mouseDraw=0;
					sendDraw( [ "s" ]);
				}
			});

			//a tool is clicked
			$(".tool").click(function(m)
			{
				//unselect all tools in that group
				$(this).parent().children(".tool").removeClass('selected');
				//select this one
				$(this).addClass('selected');
				
				var i=0;
				var cmds=new Array();
				while ($(this).attr("cmd"+i))
				{
					cmds.push($(this).attr("cmd"+i));
					i++;
				};
				
				sendDraw(cmds); 

				$("#chatInput").focus();
			});

			//clear button
			$("#clear").click(function(m)
			{
				//a clear actually creates a new drawing so the old one is preserved
				send(0,"paper_Create", { "moveClients":1 } );
			});

			
			canvasWidth=$("#canvasMouse").width();
			canvasHeight=$("#canvasMouse").height();
			
			canvas=document.getElementById('canvas');
			contextDraw=canvas.getContext('2d');
			canvas.width=canvasWidth;
			canvas.height=canvasHeight;

			canvasTemp=document.getElementById('canvasTemp');
			contextTemp=canvasTemp.getContext('2d');
			canvasTemp.width=canvasWidth;
			canvasTemp.height=canvasHeight;


			//join the specified paper
			send(0,"paper_Join", {
				"objectId":jQuery.url.param("id"),
			});


			
 		});
 				
		//we've joined a object
 		synapse_register("object_Joined",function(msg_src, msg_dst, msg_event, msg)
		{
			//we've joined a object, from now on draw on it.
			currentObjectId=msg["objectId"];
			paperModId=msg_src;
			$("#objectId").html(msg["objectId"]);
		});
 		
 				


 		synapse_register("paper_ServerDraw",function(msg_src, msg_dst, msg_event, msg)
		{
 			while(msg.length>0)
 			{
				//switch to different client 
 				if (msg[0]=="I")
	 			{
 	 				if (autoCommit && clientId)
 	 	 				clients[clientId].commit();
 		 			msg.shift();
		 			clientId=msg.shift();
		 			//need to create new client object?
		 			if (clients[clientId]==undefined)
		 			{
			 			clients[clientId]=new Cclient();
			 			clients[clientId].id=clientId;
		 			}
 				}
 				//start of complete redraw: clears everything, enables auto commit
 				else if (msg[0]=="S")
 				{
 	 				msg.shift();
 					clients=[];
					clientId=0;
					$('#clientList').empty();
					$('#chatList').empty();
					autoCommit=true; 
 					contextDraw.clearRect(0, 0, canvasWidth, canvasHeight);
 					$(".tool").removeClass('selected');
 					$(".defaultTool").addClass('selected');
 				}
				//end of complete redraw, disable auto commit.
 				else if (msg[0]=="E")
 				{
	 				msg.shift();
					autoCommit=false;
	 				//commit the last bits and update html status
	 				for (var clientI in clients)
 					{
 	 					clients[clientI].commit();
 	 					clients[clientI].updateHtml();
 					}
 					
	 				//let everyone know who we are
	 				sendDraw([ "n" , $("#clientName").val() ]);
	 	 					
					$("#loading").hide();
 				}
 				//delete client
 				else if (msg[0]=="D")
 				{
 	 				msg.shift();
 	 				if (autoCommit)
 	 	 				clients[clientId].commit();
	 	 			clients[clientId].remove();
	 	 			delete clients[clientId];
					clientId=0;
				}      
 				//let the current client object parse the rest. it returns when it encounters something unknown.
 				else
 				{
 	 				if (!clients[clientId].add(msg))
 	 				{
 	 	 				//object also doesnt know what to do...log error and skip it and hope for the best..
 	 	 				console.error("Error parsing draw commands",msg);
 	 	 				msg.shift();
 	 				}
 				}
 			}

			drawClients();
		});
 		

	




	</script>

	<style>
		body 
		{
			margin:0;
			padding:0;
			height:100%;
		} 

		.client
		{
			margin-top:2px;
			padding:5px;
			border-bottom-style:dashed;
			border-bottom-color:#aaaaaa;
		}

		#objectManager
		{
			position:absolute; 
			left:0;
			top: 0;
			width: 16em;
			bottom:0;
			border-style:none;
		}

		#canvasMouse
		{
			position:absolute; 
			left:16em;
			top: 0;
			right: 0;
			bottom:0;
			cursor:crosshair;
		}
		
		canvas
		{
			position:absolute;
			left:16em;
			top:0;
			right:0;
			bottom:0;
		}
		
		
		#loading
		{
			position:absolute;
			left:40%;
			top:40%;
		}
		
		#colors
		{
			
		}
		
		.tool
		{
			width:2em;
			max-width:2em;
			height:2em;
			max-height:2em;
			border-width:2px;
			border-style:solid;
			cursor:pointer;
			display:inline-block;
			border-color:#ffffff;
		}
		
		.selected
		{
			border-color:#aaaaaa;
		}
		
		img
		{
			border:0;
			margin:0;
			padding:0;
			display:inline;
		}
		
		#chatList
		{
			max-height:8em;
			overflow-y:scroll;
		}
		
		#clientList
		{
			max-height:8em;
			overflow-y:auto;		
		}
	</style>

</head>


<body class='ui-widget'>
	<div class='ui-widget-content' id='objectManager'>

		<div class='ui-widget-header'>Papier:</div>

		Papier nummer: <span id='objectId'></span>

		<br>

		<input type='submit' value='Nieuw' id='clear'>

		<div class='ui-widget-header'>Gereedschap:</div>

		Naam: <input id='clientName' type='text' value='' size=10>

		<div id='colors'>
			<div class='tool defaultTool' style='background-color:#000000' cmd0='c' cmd1='#000000'>&nbsp;</div>
			<div class='tool' style='background-color:#0000ff' cmd0='c' cmd1='#0000ff'>&nbsp;</div>
			<div class='tool' style='background-color:#00ff00' cmd0='c' cmd1='#00ff00'>&nbsp;</div>
			<div class='tool' style='background-color:#00ffff' cmd0='c' cmd1='#00ffff'>&nbsp;</div>
			<div class='tool' style='background-color:#FF8040' cmd0='c' cmd1='#FF8040'>&nbsp;</div>
			<div class='tool' style='background-color:#ffffff' cmd0='c' cmd1='#ffffff'>gum</div>
			<br>
			<div class='tool' style='background-color:#ff0000' cmd0='c' cmd1='#ff0000'>&nbsp;</div>
			<div class='tool' style='background-color:#ff00ff' cmd0='c' cmd1='#ff00ff'>&nbsp;</div>
			<div class='tool' style='background-color:#ffff00' cmd0='c' cmd1='#ffff00'>&nbsp;</div>
			<div class='tool' style='background-color:#999999' cmd0='c' cmd1='#999999'>&nbsp;</div>
			<div class='tool' style='background-color:#804000' cmd0='c' cmd1='#804000'>&nbsp;</div>
			<div class='tool' style='background-color:#F87217' cmd0='c' cmd1='#F87217'>&nbsp;</div>
			<br>
		</div>		

		<div id='widths'>
			<div class='tool defaultTool' cmd0='w' cmd1='1'><img src='img/pen1.png' style='width:1em' ></div>
			<div class='tool' cmd0='w' cmd1='2'><img src='img/pen1.png' style='width:1.2em'></div>
			<div class='tool' cmd0='w' cmd1='3'><img src='img/pen1.png' style='width:1.3em'></div>
			<div class='tool' cmd0='w' cmd1='4'><img src='img/pen1.png' style='width:1.4em' ></div>
			<br>
			<div class='tool' cmd0='w' cmd1='10'><img src='img/pen2.png' style='width:1em' ></div>
			<div class='tool' cmd0='w' cmd1='20'><img src='img/pen2.png' style='width:1.2em' ></div>
			<div class='tool' cmd0='w' cmd1='30'><img src='img/pen2.png' style='width:1.3em' ></div>
			<div class='tool' cmd0='w' cmd1='40'><img src='img/pen2.png' style='width:1.4em' ></div>		
		</div>


		<div class='ui-widget-header'>Chat:</div>
		<div id='chatList'></div>
		<input id='chatInput' type='text' value='' >


		<div class='ui-widget-header'>Andere mensen:</div>
		<div id='clientList'></div>


	</div>

	<canvas width=10 height=10 id='canvas'></canvas>		

	<canvas width=10 height=10 id='canvasTemp'></canvas>		

	<div id='loading' class='ui-state-highlight'>Loading...</div>

	<div id='canvasMouse'>
	</div>

	
</body>
</html>