<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- (C)edwin@datux.nl - released under GPL -->
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<title>internetpapier.nl</title>

	<script type="text/javascript" src="synapse.js"></script>

	<script type="text/javascript">

		var canvasWidth=0;
		var canvasHeight=0;
	
		//calculate browser coordinates to server coordinates
		function toServer(x,y)
		{
			return ({
				"x":Math.round((x * 10000) / canvasWidth),
				"y":Math.round((y * 10000) / canvasHeight)
			});
		}
	
		//calculate server coordinates to browser coordinates 
		function toBrowser(x,y)
		{
			return ({
				"x":Math.round((x*canvasWidth)/10000),
				"y":Math.round((y*canvasHeight)/10000)
			});
		}				

		function Cpoint(x,y)
		{
			this.x=x;
			this.y=y;

			this.copy=function(point)
			{
				this.x=point.x;
				this.y=point.y;
			}
			
		}
	
		


		
//		var lastTime=0; //last time a frame was analysed.
		var mouseInterval=50; //max update inteval in mS (can be higer if mouseMax is exceeded)
		var mouseMax=25; //max mouse pixel offset before sending (regardless of update interval)
		
		var currentGameId=0;

		var mousePoint=new Cpoint(); //current mouse position

		//mouse info sending to server:
		var mouseSendPoint=new Cpoint(); //last mousepoint sent to server
		var mouseSendTime=0; //last time the mousePosition was anaylsed by updateGameField

		var mouseDraw=0;		

		//dynamic pad positions
		var padVectors=new Array();

		var ctx;

		var currentObjectId=0;
		var paperModId=0;

		
		
		function mouseCheck(force)
		{
			//no change?
			if (mousePoint.x==mouseSendPoint.x && mousePoint.y==mouseSendPoint.y)
				return;

			currentTime=new Date().getTime();

			//send updates at a max fps, or more when the mouse moves fast, or when forced
			if (	force ||
					(currentTime-mouseSendTime>=mouseInterval) || 
					Math.abs(mousePoint.x-mouseSendPoint.x)> mouseMax ||
					Math.abs(mousePoint.y-mouseSendPoint.y)> mouseMax
			)
			{ 
				if (mouseDraw)
				{

					a=toServer(mousePoint.x,mousePoint.y);
					send(paperModId,"paper_clientDraw", [ "L", a.x, a.y ]);
					
				}
				else
				{
					a=toServer(mousePoint.x,mousePoint.y);
					send(paperModId,"paper_clientDraw", [ "m", a.x, a.y ] );
				}
				mouseSendPoint.x=mousePoint.x;
				mouseSendPoint.y=mousePoint.y;
					
				mouseSendTime=currentTime;
			}
		}

 		synapse_register("module_SessionStart",function(msg_src, msg_dst, msg_event, msg)
 		{
			send(0,"paper_GetPapers", { 
			});

			/// start local engine
			window.setInterval("mouseCheck(0)", mouseInterval);

			
			/// JAVA SCRIPT EVENT HANDLERS
			$("#newObject").click(function()
					{
						send(0,"paper_Create", {
								"objectName":$("#name").val(),
								"clientName":$("#name").val()
							});
					});



			$("#canvasMouse").mousemove(function(m)
			{
				mousePoint.x=m.pageX-$("#canvasMouse").offset().left;
				mousePoint.y=m.pageY-$("#canvasMouse").offset().top;
				mouseCheck(0);
			});

			$("#canvasMouse").mousedown(function(m)
			{
				m.preventDefault();
				mouseDraw=1;
				mouseCheck(1);
			});
					
			$("#canvasMouse").mouseup(function(m)
			{
				mouseDraw=0;
				mouseCheck(1);
			});
					

			$("#canvasMouse").mouseleave(function(m)
			{
				mouseDraw=0;
				mouseCheck(1);
			});

			canvasWidth=$("#canvasMouse").width();
			canvasHeight=$("#canvasMouse").height();
			
			canvas=document.getElementById('canvas');
			ctx=canvas.getContext('2d');
			canvas.width=canvasWidth;
			canvas.height=canvasHeight;

			canvasTemp=document.getElementById('canvasTemp');
			ctxTemp=canvasTemp.getContext('2d');
			canvasTemp.width=canvasWidth;
			canvasTemp.height=canvasHeight;
			canvasTemp.globalAlpha=0.5;
			
								
 		});
 				
		//update the object list
		synapse_register("object_Object",function(msg_src, msg_dst, msg_event, msg)
 		{
			//clear list?
			if (msg["first"])
				$('#objectList').empty();

	 		//new object?
			if ($("#object_"+msg["objectId"]).length==0)
			{
				//add to list
				var html="<div class='object' id='object_"+msg["objectId"]+"'>";
				html+="</div>";
				$('#objectList').append(html);
				
				//make it clickable
				$("#object_"+msg["objectId"]).attr('objectId',msg["objectId"]);
				$("#object_"+msg["objectId"]).click(function()
				{
					send(0,"paper_Join", {
							"clientName":$("#name").val(),
							"objectId":$(this).attr('objectId'),
						});
				});
			}

			//update the html with the actual game info:
			var html="Paper of " + msg["objectName"]  + " (#" +msg["objectId"] + "):";
			$("#object_"+msg["objectId"]).html(html);
		});

		//update the client list or status
		synapse_register("object_Client",function(msg_src, msg_dst, msg_event, msg)
 		{
	 		//its us?
			if (msg["clientId"]==msg_dst)
			{
				//we've joined a object, from now on draw on it.
				currentObjectId=msg["objectId"];
				paperModId=msg_src;
			}
//			for (var playerI in msg["players"])
	//		{
	//			html+="<div class='playerInfo'>";
		//		html+=msg["players"][playerI];
			//	html+="</div>";
		//	}
 		});

		
 		synapse_register("object_Deleted",function(msg_src, msg_dst, msg_event, msg)
		{
 			$("#object_"+msg["objectId"]).remove();
		});
 				

 		
		//incremental draw stuff
		var clientId=0;
		var clients=new Array(); 
		function Cclient()
		{
			this.mode="m";
			this.x=0;
			this.y=0;
			this.color="#000000";
			this.width=1;
		}

		/*** Drawing protocol
		
		Drawings exist of a list of instructions.
		Some instructions actually draw, while others just move the cursor or give visual indications.
		Capital commands make permanent changes and usually actually draw stuff.

		'i',<id>					Select a different client ID. (every client has its own color, line width etc settings) Usually the server automaticly sets this parameter.
		'c',<htmlcolor>				Set current drawing color
		'w',<w>						Set current line width
		't'							Switch to temporary context (only everyones last drawn object is showed)
		'p'							Switch to permanent context (normal drawing)
		'm',<x>,<y>,...         	Moves cursor to location(s)
		'L',<x>,<y>,...				Draw a line to location(s)
		'R',<x1>,<y1>,<x2>,<y2>		Draw rectangle
		'A',<x1>,<y1>,<x2>,<y2>		Draw circle
		'T',<x>,<y>,"text"			Draw text
		 */
 		synapse_register("paper_serverDraw",function(msg_src, msg_dst, msg_event, msg)
		{
 			i=0;
 			while(i<msg.length)
 			{
				//switch to different client 
 				if (msg[i]=="i")
	 			{
		 			clientId=msg[i+1];
		 			//create new client object?
		 			if (clients[clientId]==undefined)
		 			{
			 			clients[clientId]=new Cclient();
		 			}
		 			i=i+2;		 			
	 			}
	 			//switch to move mode
 				else if (msg[i]=="m")
 				{
					clients[clientId].mode="m";
					i=i+1;
 				}
	 			//switch to line mode
 				else if (msg[i]=="L")
 				{
					clients[clientId].mode="L";
					i=i+1;
 				}
 				//select color
 				else if (msg[i]=="c")
 				{
					clients[clientId].color=msg[i+1];
					i=i+2;
 				}
 				//all other stuff are just coordinates for move and line mode.
 				else
 				{
					//move
 					if (clients[clientId].mode=="m")
 					{
 	 	 				//just store the new coords
 	 	 				c=toBrowser(msg[i], msg[i+1]);
 						clients[clientId].x=c.x;
 						clients[clientId].y=c.y;
 						i=i+2;
 					}
 					//line
 					else 
 					{
	 					destination=toBrowser(msg[i], msg[i+1]);
	 					ctx.strokeStyle=clients[clientId].color;
	 					ctx.lineWidth=clients[clientId].width;
	 					ctx.beginPath();
		 				ctx.moveTo(clients[clientId].x, clients[clientId].y);
		 				ctx.lineTo(destination.x, destination.y);
						ctx.stroke();
 						clients[clientId].x=destination.x;
 						clients[clientId].y=destination.y;
						i=i+2;
	 				}  	
 				}		
 			}
 			
			//redraw the temporary context stuff
			ctxTemp.beginPath();			   
	
			//cursors
			var cW=canvasWidth/100;
			for (var clientI in clients)
			{
				ctxTemp.strokeStyle=clients[clientI].color;
				ctxTemp.lineWidth=clients[clientI].width;
				ctxTemp.moveTo(clients[clientI].x-cW, clients[clientI].y);
				ctxTemp.lineTo(clients[clientI].x+cW, clients[clientI].y);
				ctxTemp.moveTo(clients[clientI].x, clients[clientI].y-cW);
				ctxTemp.lineTo(clients[clientI].x, clients[clientI].y+cW);
			}
			ctxTemp.clearRect(0, 0, canvasWidth, canvasHeight);
			ctxTemp.stroke();
			
			//temporary shapes
		});
 		

	




	</script>

	<style>
		body 
		{
			margin:0;
			padding:0;
			height:100%;
		} 


		.color1  { color: #ff0000; } 
		.color2  { color: #00ff00; } 
		.color3  { color: #0000ff; } 
		.color4  { color: #ffff00; } 
		.color5  { color: #ff00ff; } 
		.color6  { color: #00ffff; } 
		.color7  { color: #aaff00; } 
		.color8  { color: #00ffaa; } 
		.color9  { color: #aa00aa; } 
		.color10 { color: #aa00ff; } 

		.clientInfo
		{
			width:18em;
			background:yellow;
			margin-left:1em;
		}

		#objectManager
		{
			position:absolute; 
			left:0;
			top: 0;
			width: 20em;
			bottom:0;
			border-style:solid;
		}

		#canvasField
		{
			position:absolute; 
			left:20em;
			top: 0;
			right: 0;
			bottom:0;
			border-style:solid;
			border-color:#00ff00;
			border-width:0;
			background:black;
			overflow:hidden;
		}

		#canvasMouse
		{
			position:absolute; 
			left:20em;
			top: 0;
			right: 0;
			bottom:0;
		}
		
		canvas
		{
			position:absolute;
			left:20em;
			top:0;
		}
		
		

		.cursor
		{
			position:absolute;
			left:10%;
			top:10%;
			width:1%;
			height:10%;
			margin-top:-5%;
			margin-left:-0.5%;
			background-color:#ff0000;
		}



		

		
	</style>

</head>


<body class='ui-widget'>
	<p>

	<div class='ui-widget-content' id='objectManager'>
		<div class='ui-widget-header'>Your name:</div>
		<input id='name' type='text' value=''>

		<div class='ui-widget-header'>Available papers:</div>
		Click to join...
		<div id='objectList'></div>
		<input id='newObject' type='submit' value='New paper'>
	</div>



	<canvas width=10 height=10 id='canvas'></canvas>		
	<canvas width=10 height=10 id='canvasTemp'></canvas>		
	<div id='canvasMouse'>
	</div>

	
</body>
</html>