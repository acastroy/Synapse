<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- (C)edwin@datux.nl - released under GPL -->
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<title>internetpapier.nl - BETA</title>

	<script src="svg.js"></script>
	<script type="text/javascript" src="synapse.js"></script>
	<script type="text/javascript" src="jquery.url.js"></script>
	<script type="text/javascript">

		function Cpoint(x,y)
		{
			this.x=x;
			this.y=y;
	
			this.copy=function(point)
			{
				this.x=point.x;
				this.y=point.y;
			}
			
		}
	
		var mouseInterval=50; //max update inteval in mS (can be higer if mouseMax is exceeded)
		var mouseMax=25; //max mouse pixel offset before sending (regardless of update interval)
	
		var mousePoint=new Cpoint(); //current mouse position
	
		//mouse info sending to server:
		var mouseSendPoint=new Cpoint(); //last mousepoint sent to server
		var mouseSendTime=0; //last time the mousePosition was anaylsed by updateGameField
	
		var mouseMode="";		
		var mouseTarget="";
	
		var contextDraw;
		var contextTemp;
	
		var currentObjectId=0;
		var paperModId=0;
	
		var drawMode="l";
			
		//incremental draw stuff
		var clientId=0;
		var clients=new Array(); 
		var ourId=0;

		var canvas;
		var canvasTemp;
		var canvasWidth=0;
		var canvasHeight=0;
		var drawing;
		var drawingHtml;
		
		var autoCommit=false;

		
		//filter dangerous stuff from user input.
		//NOTE: do this when you receive the data back from the server, not when sending to it!
		function filterInput(s)
		{
			return(s.replace(/</g,"&lt;").replace(/>/g,"&gt;"));
		}

		//calculate browser coordinates to server coordinates
		function toServer(x,y)
		{
			
			//return ( { "x":x, "y":y } );
			return ({
				"x":Math.round((x * 10000) / $("#drawing").width()),
				"y":Math.round((y * 10000) / $("#drawing").height())
			});
		}
	
		//calculate server coordinates to browser coordinates 
		//OBSOLETE: we use a svg viewbox
		function toBrowser(x,y)
		{
			return ( { "x":x, "y":y } );
			return ({
				"x":((x*canvasWidth)/10000),
				"y":((y*canvasHeight)/10000)
			});
		}				

		//calculate server line width to browser linewidth
		function widthToBrowser(width)
		{
			//for now we use the average of canvas width and height
			return (
					(((width*canvasWidth)/1000)+((width*canvasWidth)/1000))/2
			);
		}

		
		function paperLink(id,text)
		{
			return ("<a class='paperLink' href='paper.html?id="+id+"'>"+text+"</a>");
		}

		function addChat(html)
		{
			$('#chatList').append(html);

			//scroll to end
			var objDiv = document.getElementById("chatList");
			objDiv.scrollTop = objDiv.scrollHeight;
		}


		
		//information about the object a client is currently drawing
		function Cclient(id)
		{
			//init default settings
			this.mode="m";
			this.coords=new Array();
			this.color="#000000";
			this.width=widthToBrowser(1);
			this.serverWidth=1;
			this.text="";
			this.clientName="";
			this.id=id;

			//create cursor
//			this.svgCursor = document.createElementNS(svgns, 'circle');
//			this.svgCursor.setAttribute('cx', 200);
//			this.svgCursor.setAttribute('cy', 200);
//			this.svgCursor.setAttribute('r', 100);
//			this.svgCursor.setAttribute('id', 'test');
//			//this.svgCursor.setAttribute('fill', '#ff0000');
//			this.svgCursor.style["fill"]='#ff0000';
	
			this.svgCursor = document.createElementNS(svgns, 'polyline');
			this.svgCursor.setAttribute('points', '10,10 200,200 20,50');
			this.svgCursor.setAttribute('stroke', '#000000');
			this.svgCursor.setAttribute('id', 'test');
			this.svgCursor.setAttribute('fill', 'none');
			this.svgCursor.setAttribute('transform', 'translate(200,200)');
			var p=this.svgCursor.points.getItem(1);
			p.x=1000;
			p.y=1000;			
			
			//this.svgCursor.setAttribute('fill', '#ff0000');
			//this.svgCursor.style["fill"]='#ff0000';

			
			svgweb.appendChild(this.svgCursor);

//			drawing.appendChild(test);

			
			this.setCursor=function(x,y)
			{
				this.svgCursor.setAttribute('cx', x);
				this.svgCursor.setAttribute('cy', y);
			}
			
			//we're going to be removed, clean up any shit
			this.remove=function()
			{
				//remove dom object
				if ($("#client_"+this.id).length!=0)
		 			$("#client_"+this.id).remove();

			}

			
			//draw the object in the specified context	
			this.draw=function(context)
			{
				if (this.mode=="m")
					return;

				if (this.mode=="l" && this.coords.length>=4)
				{
					context.beginPath();
					context.strokeStyle=this.color;
					context.lineWidth=this.width;
					context.lineCap="round";
					context.lineJoin="round";
	 				context.moveTo(this.coords[0], this.coords[1]);
	 				var i=2;
	 				while (i<this.coords.length)
	 				{
	 					context.lineTo(this.coords[i], this.coords[i+1]);
	 					i=i+2;
	 				}
					context.stroke();
				}
			}


			//update the html information about this client in the clientlist
			this.updateHtml=function()
			{
				//dont do html stuff when in autoCommit mode, for performance reasons
				if (autoCommit)
					return;
				
		 		//no dom object for this client yet?
		 		//TODO:move to create?
				if ($("#client_"+this.id).length==0)
				{
					//add dom object to list
					var html="<div class='client' id='client_"+this.id+"'>";
					html+="</div>";
					$('#clientList').append(html);
				}
				object=$("#client_"+this.id);

				//name 
				if (!this.clientName)
					object.html("Client #" +this.id);
				else
					object.html(this.clientName);

				//color
				object.css('color',this.color);
				if (this.color=="#ffffff")
					object.css('background-color','#cccccc');
				else
					object.css('background-color','#ffffff');

				//"width"
				var size=0;
				if (this.serverWidth<10)
					size=(90+(this.serverWidth*10));
				else
				{
					size=(160+this.serverWidth);
				}
				object.css('font-size',""+size+"%");
	
				//drawing
				if (this.mode!="m")
					object.css('font-style','italic');
				else
					object.css('font-style','');
			} 	

			
			//clears the current draw-info, not the settings!
			this.clear=function()
			{
				this.mode="m";
				this.coords=[];
			}

			//commit the current drawing to permanent canvas, and clear it.
			this.commit=function()
			{
				this.draw(contextDraw);
				this.clear(); 			
			}
			
			//eats and processes the client commands from the array and returns as soon as it encounters a global command
			this.add=function(commands)
			{
				var ok=false;
				while (commands.length>0)
				{	
					//a new command should automaticly commit the previous one:
					//(this way the server doesnt have to store all the save-commands)

					//NOTE: try to sort this on the stuff that is used most often in Redraw mode.
					
					//all numbers are coords, if we are in some kind of drawing mode.
					if (commands[0] == parseInt(commands[0]))
					{
						c=toBrowser(commands.shift(), commands.shift());
		 				this.setCursor(c.x,c.y);
						if (this.mode=='l')
							this.coords.push(c.x, c.y);
					}
					//enable line mode
					else if (commands[0]=='l')
					{
						this.commit();
						commands.shift();
						this.mode='l';						
						this.updateHtml();						
					}
	 				//save current action permanently 
	 				else if (commands[0]=="s")
	 				{
	 	 				commands.shift();
	 	 				this.commit();
						this.updateHtml();						
	 				}
					//mouse movement
					else if (commands[0]=="m")
	 				{
						this.commit();
		 				commands.shift();
						//c=toBrowser(commands.shift(), commands.shift());
						
		 				this.mode='m';
		 				this.setCursor(commands.shift(), commands.shift());
		 			 				
	 				}
					//color
					else if (commands[0]=='c')
					{
						this.commit();
						commands.shift();
						this.color=commands.shift();
						this.updateHtml();						
					}
					//name
					else if (commands[0]=='n')
					{
						this.commit();
						commands.shift();
						//dont forget to filter!
						this.clientName=filterInput(commands.shift()).substr(0,20);
						this.updateHtml();						
					}
					//chat text
					else if (commands[0]=='.')
					{
						this.commit();
						commands.shift();

						//add text to chatList
						var html="";
						html+="<div class='chatLine'>&lt;";
						html+=this.clientName;
						html+="&gt; ";
						html+=filterInput(commands.shift());
						html+="</div>";
						addChat(html);						
					}					
					//width
					else if (commands[0]=='w')
					{
						this.commit();
						commands.shift();
						this.serverWidth=parseInt(commands.shift());
						this.width=widthToBrowser(this.serverWidth);
						this.updateHtml();						
					}
	 				//cancel current drawing action
	 				else if (commands[0]=="x")
	 				{
	 	 				commands.shift();
	 					this.clear();
						this.updateHtml();						
	 				}
					else
					{
						//we dont know, let caller handle the rest
						return(ok);
					}
					ok=true;
				}
				return(ok);
			}
		}

		

		//redraw all the clients in the temporary context
		function drawClients()
		{
			contextTemp.clearRect(0, 0, canvasWidth, canvasHeight);
			contextTemp.globalAlpha=0.8;
	
			//draw current objects
			for (var clientI in clients)
			{
				clients[clientI].draw(contextTemp);
			}
		}



		//send drawing msg to server 
		//note: you need to specifiy server coordinates instead of browser coordinates here.		
		function sendDraw(msg)
		{
			//only if we're joined to something
			if (!currentObjectId)
				return;
			
			//send it to server
			send(paperModId,"paper_ClientDraw", msg);

			//we dont get our own stuff back from the server, so we can add here.
			//this way the users doesnt see his own stuff lagged.
			//however there is a race condition when 2 users draw over eachother and release the mouse at the same time. 
			//both users will get a different result. however this is fixed on a refresh and acceptable for now.
 			
// 			if (clients[ourId]==undefined)
 //			{
	// 			clients[ourId]=new Cclient(ourId);
 		//	}

//			clients[ourId].add(commands);


	//		//refresh temporary canvas
//			drawClients();
		}


		//user moves mouse		
		function mouseMove(force)
		{

			//mouse throttling function, to prevent too many updates per second
			//no change?
			if (force!=true && mousePoint.x==mouseSendPoint.x && mousePoint.y==mouseSendPoint.y)
				return;

			currentTime=new Date().getTime();

			//send updates at a max fps, or more when the mouse moves fast
			if (	force==true ||
					(currentTime-mouseSendTime>=mouseInterval) || 
					Math.abs(mousePoint.x-mouseSendPoint.x)> mouseMax ||
					Math.abs(mousePoint.y-mouseSendPoint.y)> mouseMax 
			)	
			{ 

				var c=toServer(mousePoint.x,mousePoint.y);
				var msg={};

				//cursor
				msg['cursor']=c;
				
				if (mouseMode=="line")
				{
					msg['cmd']='update';
					msg['add']={
						'points': ' '+c.x+','+c.y
					}
				}
				else if (mouseMode=="delete")
				{ 
					if (mouseTarget!="bg")
					{
						msg['cmd']='delete';
						msg['id']=mouseTarget;
					}				
				}

				send(paperModId,"paper_ClientDraw", msg);

				mouseSendPoint.x=mousePoint.x;
				mouseSendPoint.y=mousePoint.y;
				mouseSendTime=currentTime;
			}
		}	

		//user starts a mouse operation (clicks somewhere)
		function mouseStart(m)
		{

			mouseMode=$('#modes .selected').attr("value");
			mouseTarget=m.target.id;
			
			if (mouseMode=="line")
			{
				sendDraw({
					'cmd'		:'update',
					'id'		:'new',
					'element'	:'polyline',
					'set'		: {
						'fill'			: 'none',
						'stroke'		: $('#colors .selected').attr("value"),
						'stroke-width'	: $('#widths .selected').attr("value")
					}
				});
			}

			//force a mouse move
			mouseMove(true);
		}

		//user ends operation (leaves or mouse up)
		function mouseEnd(m)
		{
			if (mouseMode!="")
			{
				mouseMode="";
				sendDraw({
					'cmd'		:'refresh'
				});
			};
		}
	    
	    synapse_register("module_SessionStart",function(msg_src, msg_dst, msg_event, msg)
 		{
			ourId=msg_dst;

			/// figure out client name
			var clientName=$.readCookie('clientName', { path:"/" } );
			if (!clientName)
			{
				//make up a "random" guest name
				clientName="User "+msg_dst;
			}
			
			//set the name input field
			$("#clientName").val(clientName);
			

			
			/// JAVA SCRIPT EVENT HANDLERS

			$("#clientName").keyup(function(m)
			{
				$.setCookie('clientName', $("#clientName").val(), { duration:365, path:"/" });
				sendDraw( [ "n" , $("#clientName").val() ] );
			});

			$("#chatInput").keydown(function(m)
			{
				if (m.keyCode==13)
				{
					sendDraw( [ "." , $("#chatInput").val() ] );
					sendDraw( [ "s" ] );
					$("#chatInput").val("");						
				}					
	 		});

			$("#chatInput").val("");
			
			//a tool is clicked
			$(".tool").click(function(m)
			{
				//unselect all tools in that group
				$(this).parent().children(".tool").removeClass('selected');
				//select this one
				$(this).addClass('selected');
				
//				var i=0;
//				var cmds=new Array();
//				while ($(this).attr("cmd"+i))
//				{
//					cmds.push($(this).attr("cmd"+i));
//					i++;
//				};
//				
//				sendDraw(cmds); 

				$("#chatInput").focus();
			});

			//clear button
			$("#clear").click(function(m)
			{
				//a clear actually creates a new drawing so the old one is preserved
				send(0,"paper_Create", { "moveClients":1 } );
			});


			//prepare canvas
			canvasWidth=$("#drawing").width();
			canvasHeight=$("#drawing").height();

			
			canvas=document.getElementById('canvas');
			contextDraw=canvas.getContext('2d');
			canvas.width=canvasWidth;
			canvas.height=canvasHeight;

			canvasTemp=document.getElementById('canvasTemp');
			contextTemp=canvasTemp.getContext('2d');
			canvasTemp.width=canvasWidth;
			canvasTemp.height=canvasHeight;

			//wait until svgloading is complete
		    window.addEventListener('SVGLoad', function() {
			    
				//create a svg node and assign it to global variable "drawing".
				drawing = document.createElementNS(svgns, "svg");

				//wait until rootobject is created
				drawing.addEventListener('SVGLoad', function(evt) 
				{
					//when its in flashmode, the references change somehow, so re-get it:				
					drawing=document.getElementsByTagNameNS(svgns, 'svg')[0];
					
					//set mouse move event
					//NOTE: pageX is not set when using chromium in flash mode? when we use jquery mousemove its ok ,but then we cant see 
					//which object is hovered over.
					drawing.addEventListener('mousemove', function(m) 
					{
						mouseTarget=m.target.id;
						mousePoint.x=m.pageX-$("#drawing").offset().left;
						mousePoint.y=m.pageY-$("#drawing").offset().top;
						mouseMove();
					});

					//set mouse click event
					drawing.addEventListener('mousedown', function(m)
					{
						if (m.preventDefault)
							m.preventDefault();
						else
							m.returnValue=false;


						mouseStart(m);

						return false;
					});

					//set mouse up event
					drawing.addEventListener('mouseup', mouseEnd)
							
					//set mouse leave event
					//(doesnt work with addeventlistener!)
					$("#drawing").mouseleave(mouseEnd);
						
					/// start mouse update engine
					window.setInterval(mouseMove, mouseInterval);

				});
				
				//set some basic attributes
				drawing.setAttribute("version", "1.2");
				drawing.setAttribute("baseProfile", "tiny");
				drawing.setAttribute("viewBox", "0 0 10000 10000");
				drawing.setAttribute("id","bg");
				drawing.setAttribute("preserveAspectRatio", "none");

				//default settings
				drawing.setAttribute("stroke-linecap","round");
				drawing.setAttribute("stroke-linejoin","round");
						
				
				//add drawing rootobject to html container
				drawingHtml = document.getElementById("drawing");
				svgweb.appendChild(drawing, drawingHtml);
		     }, false);

		
			//join the specified paper
			send(0,"paper_Join", {
				"objectId":jQuery.url.param("id"),
			});
 		});

		function reset()
		{
			$('#clientList').empty();
			$('#chatList').empty();
			autoCommit=true; 
			//drawing.
			$(".tool").removeClass('selected');
			$(".defaultTool").addClass('selected');

		}

	    
		//we've joined a object
 		synapse_register("object_Joined",function(msg_src, msg_dst, msg_event, msg)
		{
			//doesnt the url match?
			if (jQuery.url.param("id")!=msg["objectId"])
				document.location="paper.html?id="+msg["objectId"];
 			
			//we've joined a object, from now on draw on it.
			currentObjectId=msg["objectId"];
			paperModId=msg_src;
			$("#objectId").html(msg["objectId"]);
			reset();
		});
 		
 				

		/*** Drawing protocol
		
		1. alles via server: nadeel lag
		2. lokaal dingen afhandellen: inconsitency by lag/tegelijk editten
			oplossingen: 
				locking: complex, teveel message overhead en dus meer lag
				complete objectrefresh requesten als je klaar bent. nadeel: kan veel data zijn bij lange lijnen, maar dit is te optimizen door bijv points-velden weg te laten.

		Drawing stuff is done with paper_clientDraw.
		The message is translated to a paper_serverDraw and forwarded to all clients.
		The message is normally not echoed back, unless requested
		
		CAN BE SET BY CLIENT:
		cmd:		command to do:
						update: create/modify element 
						delete: remove element
						refresh: 	let the server resend an update cmd with all info about the element, to this client. 
									this is used to prevent inconsitencys due to local caching.

						
		only for updates with new (not yet existing) objects:
		element:		svg element type (e.g. circle,rect,polyline)
		
		update parameters:
		add:    	svg attributes to append data to (used for polylines)
		set:		svg attributes to set/replace


		update/delete parameters:		
		id:			element id for update/delete. 
					if set to 'new' with an update, the server will create a new element and replace it with its id.
					if not set by with an update/refresh, the id is replaced by id used in the last 'update' for this client. 
		beforeId:   set by server to the id of the element this element should be inserted before. this is important to keep the order of all the elements correct.
					normally only set when requesting a refresh.
		
		ONLY SET BY SERVER:
		src:		added by server. session id that send the message
						
		
		
		'
		 */
 		synapse_register("paper_ServerDraw",function(msg_src, msg_dst, msg_event, msg)
		{

				//create/update object
				if (msg["cmd"]=="update")
				{
					var element=document.getElementById(msg["id"]);
					//element not found? 
					if (element==null)
					{
						//create new element
						var element = document.createElementNS(svgns, msg["element"]);
						element.setAttribute('id', msg["id"]);

						//insert before existing or just append?
						var beforeElement=null;
						if (msg["beforeId"]!=null)
							beforeElement=document.getElementById(msg["beforeId"]);

						drawing.insertBefore(element, beforeElement);							
					}
					
					//we need to add/set attributes?
					if (msg["add"] || msg["set"])
					{
						for (var attrName in msg["set"])
						{
							element.setAttribute(attrName, msg["set"][attrName]);
						}							
	
						for (var attrName in msg["add"])
						{
							if (element.getAttribute(attrName)!=null)
								element.setAttribute(attrName, element.getAttribute(attrName)+msg["add"][attrName]);
							else
								element.setAttribute(attrName, msg["add"][attrName]);
						}
					}
						

				}
				//delete object
				else if (msg["cmd"]=="delete")
				{
					var element=document.getElementById(msg["id"]);
					if (element!=null)
					{
						drawing.removeChild(element);
					}	
				}
				

				//update cursor?
				if (msg.cursor!=null)
				{
					var cursor=document.getElementById('cursor'+msg["src"]);
					if (cursor==null)
					{
						console.log("CREATE");
						//create a group for this client's cursor
						cursor = document.createElementNS(svgns, 'g');
						cursor.setAttribute('id', 'cursor'+msg["src"]);
						cursor.setAttribute('stroke', '#000000');
						cursor.setAttribute('stroke-width', '10');
						drawing.appendChild(cursor);

						//add drawing to the cursor group
						var e = document.createElementNS(svgns, 'line');
						e.setAttribute('x1', '-200');
						e.setAttribute('x2', '+200');
						e.setAttribute('y1', '0');
						e.setAttribute('y2', '0');
						cursor.appendChild(e);					

						var e = document.createElementNS(svgns, 'line');
						e.setAttribute('x1', '0');
						e.setAttribute('x2', '0');
						e.setAttribute('y1', '-200');
						e.setAttribute('y2', '+200');
						cursor.appendChild(e);					

						var e = document.createElementNS(svgns, 'text');
						e.setAttribute('x', '0');
						e.setAttribute('y', '300');
						e.setAttribute('font-size','200');
						e.setAttribute('stroke','#aaaaaa');
						
						cursor.appendChild(e);					

						var textNode = document.createTextNode('psy0rz', true);
						e.appendChild(textNode);
					}
					cursor.setAttribute('transform', 'translate('+msg.cursor.x+','+msg.cursor.y+')');
					
				}
					
		});
 		

	




	</script>

	<style>
		body 
		{
			margin:0;
			padding:0;
			height:100%;
		} 

		.client
		{
			margin-top:2px;
			padding:5px;
			border-bottom-style:dashed;
			border-bottom-color:#aaaaaa;
		}

		#objectManager
		{
			position:absolute; 
			left:0;
			top: 0;
			width: 16em;
			bottom:0;
			border-style:none;
		}

		#canvasMouse
		{
			position:absolute; 
			left:16em;
			top: 0;
			right: 0;
			bottom:0;
			cursor:crosshair;
		}

		#drawing
		{
			position:absolute; 
			left:16em;
			top: 0;
			right: 0;
			bottom:0;
			cursor:crosshair;
			margin: 0;
			padding: 0;
		}

		
		canvas
		{
			position:absolute;
			left:16em;
			top:0;
			right:0;
			bottom:0;
		}
		
		
		#loading
		{
			position:absolute;
			left:40%;
			top:40%;
		}
		
		#colors
		{
			
		}
		
		.tool
		{
			width:2em;
			max-width:2em;
			height:2em;
			max-height:2em;
			border-width:2px;
			border-style:solid;
			cursor:pointer;
			display:inline-block;
			border-color:#ffffff;
		}
		
		.selected
		{
			border-color:#aaaaaa;
		}
		
		img
		{
			border:0;
			margin:0;
			padding:0;
			display:inline;
		}
		
		#chatList
		{
			max-height:8em;
			overflow-y:scroll;
		}
		
		#clientList
		{
			max-height:8em;
			overflow-y:auto;		
		}
		
		.paperLink
		{
			background-color: yellow;
			text-decoration: none;
			display:block;
		}
	</style>

</head>


<body class='ui-widget'>
	<div class='ui-widget-content' id='objectManager'>

		<div class='ui-widget-header'>Papier:</div>

		Papier nummer: <span id='objectId'></span>
		<br>
		
		<br>

		<input type='submit' value='Nieuw' id='clear'>

		<div class='ui-widget-header'>Gereedschap:</div>

		Naam: <input id='clientName' type='text' value='' size=10>

		<div id='colors'>
			<div class='tool color defaultTool' style='background-color:#000000' value='#000000'>&nbsp;</div>
			<div class='tool color ' style='background-color:#0000ff' value='#0000ff'>&nbsp;</div>
			<div class='tool color ' style='background-color:#00ff00' value='#00ff00'>&nbsp;</div>
			<div class='tool color ' style='background-color:#00ffff' value='#00ffff'>&nbsp;</div>
			<div class='tool color ' style='background-color:#FF8040' value='#FF8040'>&nbsp;</div>
			<div class='tool color ' style='background-color:#ffffff' value='#ffffff'>gum</div>
			<br>
			<div class='tool color' style='background-color:#ff0000' value='#ff0000'>&nbsp;</div>
			<div class='tool color' style='background-color:#ff00ff' value='#ff00ff'>&nbsp;</div>
			<div class='tool color' style='background-color:#ffff00' value='#ffff00'>&nbsp;</div>
			<div class='tool color' style='background-color:#999999' value='#999999'>&nbsp;</div>
			<div class='tool color' style='background-color:#804000' value='#804000'>&nbsp;</div>
			<div class='tool color' style='background-color:#F87217' value='#F87217'>&nbsp;</div>
			<br>
		</div>		

		<div id='widths'>
			<div class='tool width' value='10'><img src='img/pen1.png' style='width:1em' ></div>
			<div class='tool width' value='20'><img src='img/pen1.png' style='width:1.2em'></div>
			<div class='tool width' value='30'><img src='img/pen1.png' style='width:1.3em'></div>
			<div class='tool width defaultTool' value='40'><img src='img/pen1.png' style='width:1.4em' ></div>
			<br>
			<div class='tool width' value='100'><img src='img/pen2.png' style='width:1em' ></div>
			<div class='tool width' value='200'><img src='img/pen2.png' style='width:1.2em' ></div>
			<div class='tool width' value='300'><img src='img/pen2.png' style='width:1.3em' ></div>
			<div class='tool width' value='400'><img src='img/pen2.png' style='width:1.4em' ></div>		
		</div>

		<div id='modes'>
			<div class='tool mode defaultTool' value='line'>line</div>
			<div class='tool mode' value='delete'>delete</div>
			<div class='tool mode' value='move'>move</div>
		</div>


		<div class='ui-widget-header'>Chat:</div>
		<div id='chatList'></div>
		<input id='chatInput' type='text' value='' >


		<div class='ui-widget-header'>Andere mensen:</div>
		<div id='clientList'></div>


	</div>

	<canvas width=10 height=10 id='canvas'></canvas>		

	<canvas width=10 height=10 id='canvasTemp'></canvas>		

	<div id='loading' class='ui-state-highlight'>Loading...</div>


	<div id='drawing'></div>		


	
</body>
</html>